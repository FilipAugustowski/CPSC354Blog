10/5/2020

#Background

To be honest this is not my first Programming Languages course. Two semesters ago I studied abroad in Korea and took Korean computer science courses that were taught in English.
For the most part the lecture was done in English, however any questions that were asked were usually answered in Korean. I had to learn most things on my own and could not 
depend on many others since I only know 5 words of Korean. The language we used was called O'Caml and since the language was so obscure it was hard to find any sort of videos
to work from. Oddly enough, it was quite normal for more than half the class to fail and that is what happened to me. 

It took time, but I did well to figure out how to do a lot of the mathematical functions that we were given at the start of the course. Similar to our course here at Chapman we
were given a type definition of natural numbers and were asked to create functions like GCD, simple integrals, fast exponentiation, sigma of functions, zipper on lists 
and other odd ones. Soon I started to lose my touch with the course as we entered more theoretical and confusing concepts. More specifically it took me a while to 
figure out how the caluclator/"eval exp" idea worked. Once I did figure that out however I found that for the first time recursion was quite interesting in that a large 
number of different functions can be funneled into a "calculator" that is self contained. For the intial calculator I actually used a lot of the notes from the Discrete Mathematics
course that I had taken at Chapman a semester before. Now this is where my interest really started to come from and pushed me to keep trying until the end of the course. I found 
that it was very interesting that the building blocks of programming languages are really similar to the building blocks of our own number system. It soldified this 
idea that simple counting and addition is not as simple as one would think. 

Now within my first week of programming languages at Chapman, I found that a lot of my doubts and questions from the initial phase of the Korean programming languages course were 
answered or corrected. What was most interesting to me within week 1 and week 2 was that my idea of stemming from programming languages to simple counting could be further 
extended to physics. The most remarkable, yet simple thing about it is that any algebraic or numerical function can be applied to a stick. 

I think comparing code to statements will be the best way to illustrate my idea:

data NN = O | S NN  (If I am only working with natural numbers I either have a stick or I do not.)

-- addition 
add :: NN -> NN -> NN
add O n = n (If I add a stick to no stick I get a stick)
add (S n) m = S (add n m) (If I put together 2 sticks it will be the 2 lengths of the sticks together)

-- multiplication
mult :: NN -> NN -> NN
mult O n = O (If I have no stick to lengthen by this other stick then I get no stick)
mult (S O) n = n (If I have the smallest stick and add n many of that stick to itself it will give me the length n of the stick)
mult (S n) m = add m (mult n m) ((S N) is how many times I want to lengthen the stick, each time we decrease how many times we want to lengthen the stick we will lengthen
the stick by m)

-- subtract
subtr :: NN -> NN -> NN
subtr O n = O (If you have no stick and take away n length from a stick you will still have no stick)
subtr n O = n (If you have a stick and break off no length from it, it will be the same)
subtr (S n) (S m) = subtr n m (If you have two sticks of some random lengths and keep taking off 1 unit of length recursviley, you will be left with one stick of a 
specific length or no sticks if they are equal length)

All in all this sort of idea is odd and may not make the most sense, but to me it seems to help knowing that mathematics and programming languages can always be taken 
to physics or other mathematical displcines since all of these subjects seem to constrain or add to one another. 

