# Reversible Computing 

Over the past 80 years, computers in general have had a never ending growth in their speed, minimization of area in hardware, quality of computing, and decrease in energy use, however this seemingly exponential incline is going to come to a stop unless this idea of reversible computing is further researched and developed. This is because the current principle design for a computer today is constrained by physics and in order to continue to improve "computers" this design must be improved on to limit heat by further reducing the energy needed for computational operations. This improvement must come from switching our computing methods from irreversible computations to reversible computations.

To start to tackle this idea of reversible computing it is important to understand the idea of irreversible computing. Consider an example of a simple adder that takes two inputs to give one output. Now say you wanted to take the output and input it back into the adder to get the two initial inputs. This is irreversible in that there is no possible way for the adder function or machine to produce that result due to the nature of its design. Irreversible computing was coined by Rolf Landeur and is explored within Landauer's principle Q >= ln2 K<sub>B</sub>T which on its own just explains that there is a limit to how much energy per bit operation one can decrease until it is no longer physically possible. This limit has not been reached, but we continue to grow closer to it. The interesting thing however is that Landeur's principle only applies to irreverisble computation and one can in fact surpass the lower limit by using reversible computing. So to use the adder again as an example, a reversible version of that same setup would be to take the adder and also add a subtractor to it. When two inputs are placed within the machine, two outputs are returned: one with their sum and one with their difference. Now in fact with these two ouputs by reinputting them one could acquire the intial inputs. 

Now that is somewhat simple and it seems like we have solved our dilemma, however there is a very small catch with reversible computing. With just some simple digital logic knownledge it is clear that the reversible adder and irreversible adder are inherently different in their components. The components work their opertaion in different orders and would clearly need different ways of handling varying computations. Thus if we are going to use reversible computing we have to redesign everything... on all levels. So that means new bit adders, new multiplexers, new ALUs, new machine code, new data communication, a whole new application level, and a new version of each of the OSI layers. Furthermore, that means that all current programming languages and programs that are made as irreversible programs must be redesigned in a way that retains what they did as irreversible programs but also give the benefit of being a reversible program. There are two approaches to doing this and that is by hand or by having a program automatically translate it into a reversible program. By hand is more correct of course, but it would take forever. This then leads to a cross road which I think some will begin to diverge on. The future of computing seems to be that there will be those who continue to develop on the current irrerversible schema which will eventually hit a limit and there are those who will start from the very beginning with reversible computing to incoporate all that computer science as a discipline has gained from irreversible computing to make a fundamentally more efficient schema. 



